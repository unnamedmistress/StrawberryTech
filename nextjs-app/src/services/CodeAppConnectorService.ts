/**
 * Power Apps Code App Connector Service
 * Handles all connector operations through Power Platform generated clients
 * Replaces direct API calls with approved connector patterns
 */

// Types for connector operations
export interface ConnectorResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  correlationId?: string;
}

export interface ApprovalRequest {
  action: string;
  target: string;
  payload: any;
  severity: 'LOW' | 'MEDIUM' | 'HIGH';
}

export interface AuditLogEntry {
  action: string;
  target: string;
  severity: 'INFO' | 'WARNING' | 'ERROR';
  payloadMasked: string;
  correlationId: string;
  createdOn: string;
}

// Power Apps Connector Interface (would be generated by Power Platform)
declare global {
  interface Window {
    PowerAppsCodeApp?: {
      services: {
        outlook: any;
        sharepoint: any;
        onedrive: any;
        teams: any;
        todo: any;
        onenote: any;
        dataverse: any;
        azureOpenAI: any;
      };
    };
  }
}

class CodeAppConnectorService {
  private correlationId: string;

  constructor() {
    this.correlationId = this.generateCorrelationId();
  }

  private generateCorrelationId(): string {
    return `CONN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Generic connector call wrapper with audit logging
   */
  async callConnector<T>(
    serviceType: string,
    operation: string,
    parameters: any = {}
  ): Promise<ConnectorResponse<T>> {
    const startTime = Date.now();
    
    try {
      // Log the connector call attempt
      await this.logAuditEvent(
        `CONNECTOR_CALL_${serviceType.toUpperCase()}`,
        operation,
        'INFO',
        this.maskPayload(parameters)
      );

      // Check if Power Apps bridge is available
      if (!window.PowerAppsCodeApp?.services) {
        // In development/test mode, return mock response
        console.warn(`PowerAppsCodeApp bridge not available. Using mock for ${serviceType}.${operation}`);
        return this.getMockResponse<T>(serviceType, operation, parameters);
      }

      const service = (window.PowerAppsCodeApp.services as any)[serviceType];
      if (!service || !service[operation]) {
        throw new Error(`Connector operation ${serviceType}.${operation} not available`);
      }

      // Execute the connector operation
      const result = await service[operation](parameters);
      
      const duration = Date.now() - startTime;
      await this.logAuditEvent(
        `CONNECTOR_SUCCESS_${serviceType.toUpperCase()}`,
        operation,
        'INFO',
        `Duration: ${duration}ms`
      );

      return {
        success: true,
        data: result,
        correlationId: this.correlationId
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      await this.logAuditEvent(
        `CONNECTOR_ERROR_${serviceType.toUpperCase()}`,
        operation,
        'ERROR',
        `Error: ${errorMessage}, Duration: ${duration}ms`
      );

      return {
        success: false,
        error: errorMessage,
        correlationId: this.correlationId
      };
    }
  }

  // Outlook Connector Operations
  async getCalendarEvents(startDate: string, endDate: string) {
    return this.callConnector('outlook', 'GetEventsCalendarViewV2', {
      startDate,
      endDate
    });
  }

  async sendEmail(to: string, subject: string, body: string, isHtml: boolean = true) {
    // Require approval for email sending
    const approvalResult = await this.requestApproval({
      action: 'SEND_EMAIL',
      target: to,
      payload: { subject, body: body.substring(0, 200) + '...' },
      severity: 'MEDIUM'
    });

    if (!approvalResult) {
      throw new Error('Email send not approved');
    }

    return this.callConnector('outlook', 'SendEmailV2', {
      to,
      subject,
      body,
      isHtml
    });
  }

  async createCalendarEvent(subject: string, startDateTime: string, endDateTime: string, attendees?: string[]) {
    return this.callConnector('outlook', 'CreateEventV4', {
      subject,
      startDateTime,
      endDateTime,
      attendees
    });
  }

  // Teams Connector Operations
  async getTeams() {
    return this.callConnector('teams', 'GetTeams', {});
  }

  async getChannels(teamId: string) {
    return this.callConnector('teams', 'GetChannels', { teamId });
  }

  async postMessageToChannel(teamId: string, channelId: string, message: string) {
    // Require approval for Teams posting
    const approvalResult = await this.requestApproval({
      action: 'POST_TEAMS',
      target: `${teamId}/${channelId}`,
      payload: { message: message.substring(0, 200) + '...' },
      severity: 'MEDIUM'
    });

    if (!approvalResult) {
      throw new Error('Teams post not approved');
    }

    return this.callConnector('teams', 'PostMessageToChannel', {
      teamId,
      channelId,
      message
    });
  }

  // SharePoint Connector Operations
  async searchItems(query: string, siteUrl?: string) {
    return this.callConnector('sharepoint', 'SearchItems', {
      query,
      siteUrl
    });
  }

  async getFileContent(fileId: string) {
    return this.callConnector('sharepoint', 'GetFileContent', { fileId });
  }

  async createFile(fileName: string, content: string, folderPath: string) {
    return this.callConnector('sharepoint', 'CreateFile', {
      fileName,
      content,
      folderPath
    });
  }

  // To Do Connector Operations
  async createTask(title: string, notes?: string, dueDate?: string) {
    return this.callConnector('todo', 'CreateTask', {
      title,
      notes,
      dueDate
    });
  }

  async listTasks(listId?: string) {
    return this.callConnector('todo', 'ListTasks', { listId });
  }

  async completeTask(taskId: string) {
    return this.callConnector('todo', 'CompleteTask', { taskId });
  }

  // Azure OpenAI Assistants Connector Operations
  async uploadFile(file: File, purpose: string = 'assistants') {
    return this.callConnector('azureOpenAI', 'uploadFile', {
      file,
      purpose
    });
  }

  async createAssistantThread(assistantId?: string, tools?: any[]) {
    return this.callConnector('azureOpenAI', 'createAssistantThread', {
      assistant: assistantId,
      tools
    });
  }

  async addMessageToThread(threadId: string, role: 'user' | 'assistant', content: string, fileIds?: string[]) {
    return this.callConnector('azureOpenAI', 'addMessageToThread', {
      threadId,
      role,
      content,
      file_ids: fileIds
    });
  }

  async runThread(threadId: string, assistantId: string, instructions?: string, tools?: any[]) {
    return this.callConnector('azureOpenAI', 'runThread', {
      threadId,
      assistant_id: assistantId,
      instructions,
      tools
    });
  }

  async getRunStatus(threadId: string, runId: string) {
    return this.callConnector('azureOpenAI', 'getRunStatus', {
      threadId,
      runId
    });
  }

  async listMessages(threadId: string) {
    return this.callConnector('azureOpenAI', 'listMessages', { threadId });
  }

  async listFilesForRun(runId: string) {
    return this.callConnector('azureOpenAI', 'listFilesForRun', { runId });
  }

  async downloadFile(fileId: string) {
    return this.callConnector('azureOpenAI', 'downloadFile', { fileId });
  }

  async deleteFile(fileId: string) {
    return this.callConnector('azureOpenAI', 'deleteFile', { fileId });
  }

  /**
   * Request approval for sensitive operations
   * In production, this would show a modal dialog
   * Currently returns mock approval for development
   */
  async requestApproval(request: ApprovalRequest): Promise<boolean> {
    const approvalId = `APPROVAL-${request.action}-${Date.now()}`;
    
    await this.logAuditEvent(
      approvalId,
      request.target,
      'WARNING',
      `Approval requested: ${request.action}`
    );

    // TODO: In production, show approval modal dialog
    // For now, auto-approve in development
    console.log(`Approval requested for ${request.action}:`, request);
    
    // Mock approval logic - in production this would be user-driven
    const approved = true;
    
    await this.logAuditEvent(
      approvalId,
      request.target,
      approved ? 'INFO' : 'WARNING',
      `Approval ${approved ? 'granted' : 'denied'}: ${request.action}`
    );

    return approved;
  }

  /**
   * Central audit logging
   */
  async logAuditEvent(
    action: string,
    target: string,
    severity: 'INFO' | 'WARNING' | 'ERROR',
    payloadMasked: string
  ): Promise<void> {
    const auditEntry: AuditLogEntry = {
      action,
      target,
      severity,
      payloadMasked,
      correlationId: this.correlationId,
      createdOn: new Date().toISOString()
    };

    // Log to console for development
    console.log(`[AUDIT ${severity}] ${action}: ${payloadMasked}`, auditEntry);

    // TODO: Write to Dataverse AuditLog table
    try {
      await this.callConnector('dataverse', 'createRecord', {
        entityName: 'AuditLog',
        data: auditEntry
      });
    } catch (error) {
      console.error('Failed to write audit log to Dataverse:', error);
    }
  }

  /**
   * Mask sensitive data in payloads for audit logging
   */
  private maskPayload(payload: any): string {
    const masked = { ...payload };
    
    // Mask common sensitive fields
    const sensitiveFields = ['password', 'token', 'key', 'secret', 'email', 'phone'];
    
    const maskValue = (obj: any, key: string) => {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        obj[key] = '***MASKED***';
      }
    };

    const traverse = (obj: any) => {
      if (typeof obj === 'object' && obj !== null) {
        Object.keys(obj).forEach(key => {
          maskValue(obj, key);
          if (typeof obj[key] === 'object') {
            traverse(obj[key]);
          }
        });
      }
    };

    traverse(masked);
    return JSON.stringify(masked).substring(0, 500);
  }

  /**
   * Mock responses for development when Power Apps bridge is not available
   */
  private getMockResponse<T>(serviceType: string, operation: string, parameters: any): ConnectorResponse<T> {
    console.log(`Mock response for ${serviceType}.${operation}:`, parameters);
    
    const mockData: Record<string, Record<string, any>> = {
      outlook: {
        GetEventsCalendarViewV2: { events: [] },
        SendEmailV2: { messageId: 'mock-message-id' },
        CreateEventV4: { eventId: 'mock-event-id' }
      },
      teams: {
        GetTeams: { teams: [] },
        GetChannels: { channels: [] },
        PostMessageToChannel: { messageId: 'mock-teams-message' }
      },
      sharepoint: {
        SearchItems: { items: [] },
        GetFileContent: { content: 'mock file content' },
        CreateFile: { fileId: 'mock-file-id' }
      },
      todo: {
        CreateTask: { taskId: 'mock-task-id' },
        ListTasks: { tasks: [] },
        CompleteTask: { success: true }
      },
      azureOpenAI: {
        uploadFile: { fileId: 'mock-file-id' },
        createAssistantThread: { threadId: 'mock-thread-id' },
        addMessageToThread: { messageId: 'mock-message-id' },
        runThread: { runId: 'mock-run-id' },
        getRunStatus: { status: 'completed' },
        listMessages: { messages: [] },
        listFilesForRun: { files: [] },
        downloadFile: { content: 'mock file content' },
        deleteFile: { success: true }
      }
    };

    return {
      success: true,
      data: mockData[serviceType]?.[operation] || { mock: true } as T,
      correlationId: this.correlationId
    };
  }
}

// Export singleton instance
export const connectorService = new CodeAppConnectorService();
export default CodeAppConnectorService;